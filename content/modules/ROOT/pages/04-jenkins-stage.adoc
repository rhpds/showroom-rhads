= Advanced Developer Suite Demo Instructions
Red Hat Advanced Developer Suite with Enterprise Contract and Artifact Signer
:sectnums:
:source-highlighter: rouge
:toc: macro
:toclevels: 1

toc::[]

== Overview

This guide is designed for technical sales engineers to demonstrate a secure software supply chain using:

- Red Hat Advanced Developer Suite (ADS)
- Enterprise Contract (EC)
- GitOps with Argo CD
- Artifact Signer

The goal of the demo is to show how tagging a release in Git can trigger a Jenkins pipeline that:

- Validates the container image using Enterprise Contract
- Tags the verified image using the Git tag value
- Promotes the image to the staging environment via GitOps
- Automatically deploys the application using Argo CD

The demo uses a Jenkins pipeline that relies on a shared Jenkins library:
`RHTAP_Jenkins@main`

[NOTE]
====
The code snippets in this guide are provided for illustrative and simplified purposes, as they are intended for demonstration only. Always refer to the actual Jenkins pipeline and repository configuration for production-ready details.
====


== Starting the Demo: Tag the Release

Let your audience know that this demo is initiated by tagging a release in Git. This Git event triggers a Jenkins pipeline which performs validation and promotes the image to staging.

Choose one of the following methods to create the tag:

=== Option 1: Tag via GitLab UI

. Open your GitLab repository {gitlab_url}/development/my-quarkus-jnk[my-quarkus-jnk^] and sign in using username `{gitlab_user}` and password `{gitlab_user_password}`.
+
image::jenkins-stage-1.png[]
. In the left navigation menu, go to *Code > Tags > New Tag*
+
image::tekton-stage-2.png[]
. Fill in the tag details:
  - **Tag name**: `v1.0`
  - **Target branch**: `main`
. Click *Create Tag*
+
image::tekton-stage-3.png[]

=== Option 2: Tag via Git CLI

Alternatively, you can trigger the pipeline by pushing a Git tag from your local machine:

[source,bash]
----
git tag v1.0
git push --tags
----

Now guide your audience to *Developer Hub*:

. Go to the *my-quarkus-jnk* component.
. Click the *CI* tab to see pipeline runs.
. Click on the *View build* icon on the *promote-to-stage* build to follow progress
+
image::jenkins-stage-4.png[]
. Click *Open Blue Ocean* to view the pipeline stages
+
image::jenkins-stage-5.png[]

Tell your audience:
“This run is triggered by the Git tag and promotes the image to staging, while validating it with Enterprise Contract.”

== Pipeline Tasks

image::jenkins-stage-6.png[]
As the Jenkins pipeline runs, guide the audience through each of the following tasks. Each task demonstrates a critical part of the secure software supply chain.

=== Task 2: verify-ec

Explain to the audience that this is the security checkpoint in the pipeline.

The pipeline runs Enterprise Contract validations to ensure the image is trustworthy, compliant, and safe for promotion. This happens in two main steps:

.Step 1: Initialize Cosign trust root
This step sets up the local trust policy for verifying digital signatures using Cosign.

[source,bash]
----
cosign initialize \
  --mirror http://tuf.tssc-tas.svc \
  --root http://tuf.tssc-tas.svc/root.json
----

.Step 2: Validate the image using Enterprise Contract

[source,bash]
----
ec validate image \
  --image quay.tssc-quay/tssc/my-quarkus-jnk:123456 \
  --policy git::github.com/org/ec-policies//default \
  --public-key k8s://openshift/trusted-keys \
  --output json
----

This validation checks:

- That the image is digitally signed with Cosign
- That an SBOM is present (in SPDX or CycloneDX format)
- That provenance metadata is available (how and where the image was built)
- That no critical or high CVEs are present
- That it passes all organizational policy rules

Tell your audience:

> “This step ensures only secure, verified, and compliant artifacts move forward. If the image fails any of these checks, the pipeline stops here.”

Optional: Consider running a demo with a failed image to showcase how enforcement works.


=== Task 2: verify-ec

Let your audience know this is where supply chain security checks occur.

The goal here is to validate the image to ensure it’s safe, verified, and meets your organization’s security policies.

.Step 1: Initialize trust with Cosign

This step sets up the trust system Cosign uses to verify digital signatures.

[source,bash]
----
cosign initialize \
  --mirror http://tuf.tssc-tas.svc \
  --root http://tuf.tssc-tas.svc/root.json
----

Explain:
- `cosign` is a tool that verifies if a container image was signed by a trusted source.
- `tuf.tssc-tas.svc` is the internal trust server that holds our root of trust data.

.Step 2: Validate the image with Enterprise Contract

[source,bash]
----
ec validate image \
  --image quay.tssc-quay/tssc/my-quarkus-jnk:123456 \
  --policy git::github.com/org/ec-policies//default \
  --public-key k8s://openshift/trusted-keys \
  --output json
----

This command checks the image against a set of security and compliance rules.

Explain:
- `ec validate` means "Enterprise Contract is now checking your image"
- `--image` is the container image you want to validate
- `--policy` is the set of rules it must follow (stored in Git)
- `--public-key` is used to confirm the image was signed by someone trusted
- `--output json` gives a clear pass/fail report in JSON format

.Validation checks performed:

- *Digital signature (Cosign)*
  → Confirms the image wasn’t tampered with and came from a trusted build system.

- *SBOM (Software Bill of Materials)*
  → A list of everything that went into the image — like an ingredients label for software.

- *Provenance metadata*
  → Details of how and where the image was built (e.g., which pipeline, commit, environment).

- *CVE scanning*
  → Checks for known security vulnerabilities (Critical or High ones cause failure).

- *Organizational policy compliance*
  → Enforces any rules set by your security or platform team.

Tell your audience:

> “If any of these checks fail, the pipeline stops — which means no risky code makes it to the next stage.”

Optional: Simulate a failed validation by pushing an unsigned image or one missing SBOM to show enforcement in action.

=== Task 3: update-image-tag-for-stage

Let the audience know that once the image passes validation, this step applies a release version tag.

[source,bash]
----
skopeo copy \
  docker://quay.tssc-quay/tssc/my-quarkus-jnk:123456 \
  docker://quay.tssc-quay/tssc/my-quarkus-jnk:v1.0
----

Explain:
- Applies a human-readable version tag to the validated image.
- Ensures only verified images are tagged for release.
- This tagged image is used for deployment to the `stage` environment.


=== Task 4: deploy-to-stage

Let the audience know that this step updates the GitOps repository with the new image tag.

The pipeline modifies:

`overlays/stage/deployment-patch.yaml`

[source,yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-quarkus-jnk
spec:
  template:
    spec:
      containers:
        - name: my-quarkus-jnk
          image: quay.tssc-quay/tssc/my-quarkus-jnk:v1.0
----

This patch is referenced by `kustomization.yaml`:

[source,yaml]
----
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
resources:
  - ../../base
patchesStrategicMerge:
  - deployment-patch.yaml
----

Mention:
- Jenkins commits and pushes this change to the GitOps repository.
- Argo CD detects the update and syncs the deployment to the `stage` environment automatically.

== Summary

To quickly summarize:

[cols="1,1",options="header"]
|===
| Step | Description

| Tag Push
| Triggers the staging pipeline and updates `overlays/stage/`

| gather-images
| Resolves the Git tag to a commit, generates `images.json` for validation

| verify-ec
| Validates the image signature, SBOM, provenance, CVEs, and policy compliance

| update-image-tag-for-stage
| Tags the verified image with the release version (e.g., `v1.0`)

| deploy-to-stage
| Updates the `overlays/stage` directory to trigger deployment via Argo CD
|===

== Key Takeaways

- Tagging a Git release initiates a secure image promotion process.
- Enterprise Contract enforces compliance, provenance, and security checks.
- Jenkins shared library `RHTAP_Jenkins@main` standardizes CI/CD workflows.
- GitOps overlays provide clear, auditable environment separation.
- Argo CD ensures continuous deployment aligned with Git state.

== Optional Enhancements

Use these to explore additional details during the demo:

- Simulate a failed Enterprise Contract validation by using an unsigned image
- Show the image in Quay with both tags: `:abc123` (commit) and `:v1.0` (release)
- Open the Argo CD UI and demonstrate syncing the `stage` environment
- Display the Enterprise Contract policy bundle used for validation
- Explain that production promotion uses a similar process, triggered by a GitLab release and applied to the `prod` overlay
