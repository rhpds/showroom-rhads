== Pipeline Flow

=== Git Tag Triggers the Pipeline

You’ll start by showing how a Git tag acts as a release trigger. This simulates what an ACME developer would do to promote a verified image.

=== Option 1: Tag via GitLab UI

Walk the audience through the GitLab web interface:

. Open your GitLab repository {gitlab_url}/development/my-quarkus-tkn[my-quarkus-tkn^] and sign in using username `{gitlab_user}` and password `{gitlab_user_password}`.
+
image::tekton-stage-1.png[]
. In the left menu, click on *Code > Tags > New Tag*.
+
image::tekton-stage-2.png[]
. Enter a version tag like `v1.2.3`.
. Choose the target branch (typically `main`).
. Click *Create Tag*.
+
image::tekton-stage-3.png[]

[NOTE]
====
_As you do this, explain:_
"This simulates a release event. The moment this tag is created, a GitLab webhook kicks off the OpenShift Pipelines pipeline — the one that promotes the image to ACME's staging environment."
====

=== Option 2: Tag via Git CLI

If you prefer the CLI, demonstrate with:

[source,bash]
----
git tag v1.2.3
git push --tags
----

[NOTE]
====
_Explain:_
"This does the same thing — triggers the pipeline tied to this Git tag."
====

Now guide your audience to *Developer Hub*:

. Go to the *my-quarkus-tkn* component.
. Click the *CI* tab to see pipeline runs.
. Expand the job labeled *promote-to-stage* to follow its progress.
+
image::tekton-stage-3.png[]

[NOTE]
====
Use this view to explain each task as it executes.
Let your audience see the automation in action — no manual approvals, just policy-driven promotion.
====


== Pipeline Tasks

As the OpenShift Pipelines pipeline runs, guide your audience through the following key tasks — each one enforcing a layer of software supply chain security for ACME’s release process.

=== Task 1.1: `extract-destination-image-tag`

Say:
"This task grabs the Git tag we just created — like `v1.2.3` — and makes it available as a variable in the pipeline."

Explain:
It’s a simple but essential step. Every subsequent task needs to know which version it’s working with, and this tag becomes the anchor point for traceability.

=== Task 1.2: `gather-images-to-verify`

Say:
"This task figures out which image we're actually trying to promote."

Explain:
During the original CI build, the image was tagged with the Git commit ID — something like `abc123def456`. Now we’re mapping the Git tag (e.g., `v1.2.3`) back to that commit ID, and linking that to the corresponding container image.

The result is saved into an `images.json` file, which becomes the single source of truth for what’s about to be verified and promoted.

.Sample `images.json`
[source,json,subs="attributes"]
----
{
  "components": [
    {
      "containerImage": "quay.tssc-quay/tssc/my-quarkus-tkn:abc123def456",
      "source": {
        "git": {
          "url": "{gitlab_url}/development/my-quarkus-tkn",
          "revision": "abc123def456"
        }
      }
    }
  ]
}
----

[NOTE]
====
_Point out:_
"This mapping between Git commit and container image provides end-to-end traceability — we know exactly what code went into what image."
====


=== Task 2: `verify-enterprise-contract`

Say:
"This is where ACME enforces policy before anything reaches staging. We validate the image using Enterprise Contract — a tool that ensures everything meets the organization’s security and compliance requirements."

==== Do:

First, the pipeline bootstraps trust using `cosign` and a local TUF (The Update Framework) server:

[source,bash]
----
cosign initialize \
  --mirror https://tuf.tssc-tas.svc \
  --root https://tuf.tssc-tas.svc/root.json
----

Then, the Enterprise Contract CLI performs validation:

[source,bash]
----
ec validate image \
  --image quay.tssc-quay/tssc/my-quarkus-tkn:abc123... \
  --policy default \
  --public-key k8s://openshift/trusted-keys \
  --output json
----

==== Explain:

This step enforces multiple critical validations:

- *Cosign signature check* — ensures the image is cryptographically signed.
- *SBOM presence* — confirms that a Software Bill of Materials exists (e.g., CycloneDX).
- *Provenance* — verifies how and where the image was built.
- *CVE scan* — checks for known vulnerabilities.
- *Policy compliance* — validates against rules defined by ACME’s platform team.

.Sample output
[source,json]
----
{
  "successes": [
    "Image is signed and verified with cosign",
    "SBOM (CycloneDX) is present",
    "Provenance attestation matches source repo",
    "No critical vulnerabilities found"
  ],
  "failures": []
}
----

[NOTE]
====
The `ec` CLI bundles multiple supply chain checks into one command, making complex validation simple and repeatable.
====

[IMPORTANT]
====
If any check fails, the pipeline halts.
If everything passes, the image moves forward to the next promotion step.
====


=== Task 3: `copy-image`

Say:
"Now that ACME’s image has passed validation, we promote it. But instead of rebuilding, we tag the verified image with the release version for clarity and traceability."

==== Do:

Use `skopeo` to copy and retag the image:

[source,bash]
----
skopeo copy \
  docker://quay.tssc-quay/tssc/my-quarkus-tkn:abc123... \
  docker://quay.tssc-quay/tssc/my-quarkus-tkn:v1.2.3
----

==== Explain:

- The image was already built and validated — no need to rebuild.
- We simply promote it using a clean, human-readable tag (`v1.2.3`).
- This ensures traceability from commit → image → deployment.

[IMPORTANT]
====
This guarantees that only validated artifacts are promoted — no sneaky image changes slip through.
====

=== Task 4: `update-deployment`

Say:
"Now we need to reflect this new image in the actual environment — and we do that by updating the GitOps repo."

==== Do:

The deployment overlay in the `stage` environment gets updated with the new image tag.

.`kustomization.yaml`
[source,yaml]
----
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
patchesStrategicMerge:
  - deployment-patch.yaml
resources:
  - ../../base
----

.`deployment-patch.yaml`
[source,yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-quarkus-tkn
spec:
  template:
    spec:
      containers:
        - name: my-quarkus-tkn
          image: quay.tssc-quay/tssc/my-quarkus-tkn:v1.2.3
----

.Example Git diff
[source,diff]
----
-          image: quay.io/redhat-appstudio/rhtap-task-runner:latest
+          image: quay.tssc-quay/tssc/my-quarkus-tkn:v1.2.3
----

==== Explain:

- The pipeline commits and pushes this change to the GitOps repo.
- Argo CD is watching the repo and detects this change automatically.
- It then syncs the new deployment to the cluster.

[NOTE]
====
No manual `kubectl`, no YAML editing in the console — the system reacts to Git. That’s the GitOps advantage.
====

== Part 5 — Wrap-Up

=== Summary

|===
| Phase | Purpose

| 1.1 extract-destination-image-tag
| Extracts the commit ID of the Git tag. The commit ID is the image tag of the image we are promoting to `stage`.

| 1.2 gather-images-to-verify
| Selects the image based on the commit ID and generates `images.json`.

| 2 verify-enterprise-contract
| Validates signature, SBOM, provenance, CVEs — all enforced via the EC CLI.

| 3 copy-image
| Promotes the validated image with a human-readable tag (e.g., `v1.2.3`).

| 4 update-deployment
| Updates `overlays/stage` to trigger Argo CD deployment.
|===

=== Key Takeaways

- No manual validation or promotion — it’s all automated.
- Only signed, validated, policy-compliant images move forward.
- Cosign and EC CLI give us both cryptographic and policy-based trust.
- Git remains the single source of truth for promotion and deployment.
- Fully automated and auditable — ideal for platform teams and auditors alike.

=== Optional Enhancements

You can optionally demo:

- A failed validation scenario (e.g., using an image missing an SBOM).
- The actual Enterprise Contract policy bundle in YAML format.
- The new image tag (e.g., `v1.2.3`) in the Quay UI.
- The Argo CD interface syncing the deployment after the GitOps change.

