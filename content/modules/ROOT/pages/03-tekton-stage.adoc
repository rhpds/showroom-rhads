= Advanced Developer Suite Demo Script
Red Hat Advanced Developer Suite with Jenkins, Enterprise Contract, and GitOps
:icons: font
:sectnums:
:source-highlighter: rouge

== üéØ Purpose

This demo shows how Red Hat Advanced Developer Suite (TAP), Enterprise Contract (EC), and GitOps work together using Jenkins to securely promote container images based on Git tags. The flow uses a shared Jenkins library to handle validation and deployment logic. This illustrates trusted software supply chain practices and fully automated promotion.

== üß© Setup Summary

Ensure the following are ready before the demo:

- Jenkins is deployed with the `RHTAP_Jenkins` shared library configured
- CI pipeline builds and pushes images tagged by commit SHA
- The GitOps repo is wired to Argo CD
- Enterprise Contract policies and signing infrastructure are available

== üöÄ Trigger the Pipeline via Git Tag

Mention:
- Promotion starts by creating a Git tag to mark the release version.
- This can be done in two ways:

[source,bash]
----
# Option 1: Using Git CLI
git tag v1.2.3
git push origin v1.2.3
----

- Or,

Mention:
- Option 2: Using the GitLab UI to create a release tag.

Explain:
- In GitLab, navigate to your project‚Äôs **Repository > Tags**, then click **‚ÄúNew tag‚Äù**.
- Enter the tag name (e.g., `v1.2.3`) and choose the target branch or commit.
- Creating the tag this way triggers the same Jenkins pipeline through the webhook.

Mention:
- Both methods ensure the pipeline starts automatically, keeping release management flexible for teams.

Explain:
- This tagging step is the **single source of truth** for promotion, linking the release back to a specific commit.

== üîÑ Jenkins Pipeline Starts

Show:
- The Jenkins pipeline configuration with the shared library reference.

[source,groovy]
----
library identifier: 'RHTAP_Jenkins@main', retriever: modernSCM([
  $class: 'GitSCMSource',
  remote: 'https://<gitlabHost>/rhdh/tssc-sample-jenkins.git'
])
----

Mention:
- The library wraps common TAP functions like image validation and GitOps deployment.
- This makes the pipeline reusable and consistent across teams.

== üß± Stage: Gather Image Metadata

Mention:
- This stage looks up the commit associated with the Git tag.
- It generates `IMAGES_TO_VERIFY` with the container image and its source repo and commit.

[source,json]
----
{
  "components": [
    {
      "containerImage": "quay.tssc-quay/tssc/my-quarkus-app:abc123...",
      "source": {
        "git": {
          "url": "https://gitlab.example.com/my-org/my-repo",
          "revision": "abc123..."
        }
      }
    }
  ]
}
----

Highlight:
- This ensures the image being promoted is tied to the exact commit that was tagged.

== ‚úÖ Stage: Verify with Enterprise Contract

Mention:
- This is the security gate‚Äînothing moves forward unless this step passes.
- Uses `rhtap.verify_enterprise_contract()` from the shared library.

[source,groovy]
----
rhtap.info('verify_enterprise_contract')
rhtap.verify_enterprise_contract()
----

Explain:
- Cosign trust is initialized from a TUF server.
- EC CLI verifies:
  - Signature
  - SBOM (CycloneDX/SPDX)
  - SLSA provenance
  - CVE thresholds
  - Organization-specific rules

Show:
- Sample output from `ec validate image`.

[source,json]
----
{
  "successes": [
    "Image is signed and verified with cosign",
    "SBOM (CycloneDX) is present",
    "Provenance attestation matches source repo",
    "No critical vulnerabilities found"
  ],
  "failures": []
}
----

Optional:
- Show the EC policy bundle source or switch to a failure scenario (e.g., unsigned image).

== üè∑Ô∏è Stage: Promote Image via Skopeo

Mention:
- The validated image is re-tagged using Skopeo.
- This applies the Git tag (e.g., `v1.2.3`) to the image digest.

[source,bash]
----
skopeo copy \
  docker://quay.tssc-quay/tssc/my-quarkus-app:abc123... \
  docker://quay.tssc-quay/tssc/my-quarkus-app:v1.2.3
----

Highlight:
- This avoids pushing a new image‚Äîonly metadata is updated.
- Ensures that only verified images are promoted.

== üö¢ Stage: Update GitOps Deployment

Mention:
- The shared library function `rhtap.update_deployment()` patches the GitOps repo with the new image tag.

[source,groovy]
----
rhtap.info('update_deployment')
rhtap.update_deployment()
----

Explain:
- `deployment-patch.yaml` is updated to reference `v1.2.3`.
- Change is committed and pushed to the GitOps repo.
- Argo CD detects and syncs the change to the staging environment.

[source,yaml]
----
spec:
  template:
    spec:
      containers:
        - name: my-quarkus-app
          image: quay.tssc-quay/tssc/my-quarkus-app:v1.2.3
----

Optional:
- Show the commit in the GitOps repo.
- Flip to the Argo CD UI to show the sync and rollout.

== üìã Recap Table

|===
| Stage | Purpose | Shared Library Used

| Tag Trigger
| Kick off the pipeline via Git tag
| ‚Äì

| Gather Metadata
| Identify commit and image for validation
| ‚Äì

| Verify EC
| Validate image with signatures, SBOM, CVEs
| `rhtap.verify_enterprise_contract()`

| Promote Image
| Apply human-readable Git tag to verified image
| ‚Äì

| Update GitOps
| Patch deployment to use the promoted image
| `rhtap.update_deployment()`
|===

== üí° Key Takeaways

Mention:
- Developers just tag a release‚Äîpolicy and promotion are automatic.
- Security and compliance are enforced without blocking innovation.
- Everything is Git-driven: traceable, auditable, and repeatable.
- Jenkins shared libraries make it easy to reuse this flow across teams.

== üß™ Optional Extensions

Consider showing:
- A failed validation (e.g., missing SBOM or unsigned image)
- Quay UI with the new tag applied
- The Enterprise Contract policy repo
- Argo CD auto-sync in real time
