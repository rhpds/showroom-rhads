= Advanced Developer Suite Demo Narrative
Red Hat Advanced Developer Suite with Enterprise Contract and GitOps Promotion using Jenkins
:icons: font
:sectnums:
:source-highlighter: rouge

== Overview

This guide describes how to demonstrate a pipeline using Red Hat Advanced Developer Suite (TAP), Enterprise Contract (EC), and Argo CD to securely promote container images from staging to production. The pipeline supports both Git tag and GitLab release triggers using a shared flow. This implementation uses *Jenkins*, executed in a Kubernetes environment with custom agents and secure credential management.

== Trigger Model

[cols="1,1,1,1",options="header"]
|===
|Trigger Type | Triggered By | Target Environment | GitOps Overlay

| Tag push
| `git push tag v1.2.3`
| Staging
| `overlays/stage/`

| GitLab Release (via UI)
| GitLab UI “Create Release from Tag”
| Production
| `overlays/prod/`
|===

== 2. GitLab Release – Promote to Production

Once the image is verified in staging, a developer promotes it to production by creating a GitLab Release from the tag.

To do this:

. Navigate to the repository in GitLab.
. Go to *Deploy > Releases*.
. Click *New Release*.
. Select the existing tag (e.g. `v1.2.3`).
. Optionally add release notes and click *Create release*.

This triggers a webhook, which launches the same Jenkins pipeline. The pipeline detects the trigger source (a release webhook), and enters **production promotion mode**.

=== Task 1.1 `extract-destination-image-tag` - Extract Gitlab tag value

The Jenkins pipeline uses a shell script to extract the GitLab release tag via the GitLab API and uses it to build the image URL.

This is part of the `gather-images` stage.

== Task 1.2  `gather-images-to-verify` – Generate `images.yaml`

This step creates the input for Enterprise Contract validation by generating a file called `images.yaml`. It points to the container image that was tagged during the deployment to stage, i.e., the tag value created in GitLab.

This is performed in the `gather-images` stage of the Jenkins pipeline.

.Example `images.yaml`
[source,yaml]
----
components:
  - name: my-quarkus-app
    containerImage: quay.tssc-quay/tssc/my-quarkus-app:v1.2.3
----

== Task 2 `verify-enterprise-contract` – Validate Image and Metadata

Before promoting, the image is validated using the Enterprise Contract CLI. This enforces key policies such as:

- Signed with Cosign
- SBOM present
- SLSA provenance
- No high/critical CVEs
- Compliance with organization rules

In Jenkins, this is handled in the `verify-ec` stage using the `rhtap.verify_enterprise_contract()` step.

First, the Cosign trust root must be initialized:

[source,bash]
----
cosign initialize \
  --mirror https://tuf.tssc-tas.dev \
  --root https://tuf.tssc-tas.dev/root.json
----

Then the image is validated:

[source,bash]
----
ec validate image \
  --image quay.tssc-quay/tssc/my-quarkus-app:v1.2.3 \
  --policy default \
  --public-key k8s://openshift/trusted-keys \
  --output json
----

.Sample output
[source,json]
----
{
  "successes": [
    "Image is signed and verified with cosign",
    "SBOM (CycloneDX) is present",
    "Provenance matches repository",
    "No critical vulnerabilities found"
  ],
  "failures": []
}
----

If validation fails, the Jenkins pipeline aborts and the image is not promoted.

== Task 3 - `update-deployment` - Create a new image tag based on the *stage* image

If the image passes validation, it is re-tagged using `skopeo`.

This is implemented in the Jenkins stage `update-image-tag-for-stage`, using a dedicated container running the Skopeo CLI:

[source,bash]
----
skopeo copy \
  docker://quay.tssc-quay/tssc/my-quarkus-app:v1.2.3 \
  docker://quay.tssc-quay/tssc/my-quarkus-app:prod-v1.2.3
----

This makes the validated image accessible via the human-readable release tag. The new tag value is the old tag prepended with the word *prod-*

== 6. Update GitOps Repository (Staging or Production)

This step is triggered by a **GitLab release**, so the `overlays/production/` is updated.

The Jenkins pipeline commits a change to the GitOps repository by updating the appropriate Kustomize overlay using the `rhtap.update_deployment()` step in the `deploy-to-prod` stage.

.`deployment-patch.yaml`
[source,yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-quarkus-app
spec:
  template:
    spec:
      containers:
        - name: my-quarkus-app
          image: quay.tssc-quay/tssc/my-quarkus-app:prod-v1.2.3
----

.Example Git diff:
[source,diff]
----
-          image: quay.io/redhat-appstudio/rhtap-task-runner:latest
+          image: quay.tssc-quay/tssc/my-quarkus-app:prod-v1.2.3
----

This file is committed to the GitOps repository, and Argo CD automatically deploys it to the production environment.

== Summary

[cols="1,1",options="header"]
|===
| Step | Description

| Tag Push
| Triggers staging pipeline and GitOps update for `overlays/staging/`

| GitLab Release
| Triggers production promotion pipeline via webhook

| gather-images-to-verify
| Selects the image that is tagged with the value of the GitLab tag (during the deployment to stage) which is attached to the release

| verify-enterprise-contract
| Validates the image’s integrity, provenance, and compliance

| Tagging
| Tags the verified image using the Git release tag prepended with the word *prod-*

| GitOps Update
| Updates `overlays/production/` for Argo CD
|===

== Key Takeaways

- The same Jenkins pipeline is reused for both staging and production, depending on the Git event.
- Only GitLab UI–created releases trigger production deployment.
- Promotion to prod requires a release and ensures only staged images are promoted
- Enterprise Contract ensures only secure and compliant artifacts reach production.

== 🧩 Optional Enhancements

* *Integrate Red Hat Advanced Cluster Security (ACS)*
  → Scan the image and deployment for vulnerabilities and policy violations before promotion
  → Include ACS steps in the pipeline to enforce security gates beyond EC validation

* *Add Slack or email notifications*
  → Notify stakeholders when a release is promoted or validation fails
  → Improve visibility into release activity and policy enforcement

* *Include signature verification for Git tags*
  → Ensure that only cryptographically signed tags can trigger production promotion
  → Strengthen trust in Git operations and release integrity

* *Promote via GitHub or CLI*
  → Demonstrate how the same flow can be adapted for GitHub Releases or CLI-driven tag pushes
  → Highlight flexibility of the pipeline’s trigger model

* *Track pipeline runs in Developer Hub or Jenkins UI*
  → Show how platform engineers or auditors can trace promotion history
  → Surface links to logs, artifacts, and Git metadata

* *Enforce RBAC for release creation*
  → Limit who can trigger production deployments by restricting GitLab release permissions
  → Introduce tighter governance for critical environments
