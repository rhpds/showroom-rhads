= Advanced Developer Suite Demo Narrative
Red Hat Advanced Developer Suite with Enterprise Contract and GitOps Promotion using Jenkins
:icons: font
:sectnums:
:source-highlighter: rouge
:toc: macro
:toclevels: 1

toc::[]

== Overview

Welcome! In this demo, you'll see how Red Hat’s Advanced Developer Suite (ADS), Enterprise Contract (EC), and Argo CD work together to securely promote container images from staging to production using Jenkins.

We’ll walk through a Jenkins pipeline that can be triggered by either Git tag pushes or GitLab releases. The pipeline integrates policy enforcement and GitOps automation to ensure only compliant images are promoted to production.

[NOTE]
====
The code snippets shown here are simplified for demo purposes. The actual pipeline may include additional details specific to your environment.
====

== Pipeline Flow

=== Say
* We have two types of triggers configured in this setup: one for staging and one for production.

=== Do
. Push a Git tag to simulate a staging promotion
. Create a GitLab release to simulate a production promotion

=== Explain
The pipeline reacts differently based on the trigger:

- A simple Git tag push promotes the image to *staging* using the `stage` overlay.
- A GitLab Release (created via the UI) triggers a *production* promotion using the `prod` overlay.

This separation allows teams to enforce distinct policies and approval flows for different environments, while still using the same Jenkins pipeline under the hood.

== GitLab Release – Promote to Production

=== Say
* Now let’s see how a developer promotes a validated image from staging to production using a GitLab Release.

=== Do
. Open your GitLab repository: {gitlab_url}/development/my-quarkus-jnk[my-quarkus-jnk^]  
  Use username: `{gitlab_user}` and password: `{gitlab_user_password}`.
. In the left menu, go to *Deploy > Releases*
. Click *New Release*
. Select the existing tag, such as `v1.2.3`
. Optionally add release notes
. Click *Create release*

. Go to Developer Hub and select the `my-quarkus-jnk` component
. Switch to the **CI** tab
. Locate the build labeled **promote-to-prod**
. Click **View build** and then **Open Blue Ocean** to walk through the Jenkins pipeline stages

=== Explain
Creating a GitLab release triggers a webhook that starts the Jenkins pipeline. The pipeline automatically detects that this is a *release event* and switches into production promotion mode. This ensures the same validated image is now promoted to the production environment.

The same Jenkins pipeline is reused, but its behavior changes based on the trigger type — a Git tag push promotes to staging, while a GitLab release promotes to production.

== Pipeline Tasks

=== Say
* Let’s walk through what happens in each step of the Jenkins pipeline as we promote the image to production.
* Each task here is essential for ensuring a secure and trusted software delivery pipeline.

=== Task 1: gather-images

=== Say
* The first thing Jenkins needs to know is: what exactly are we promoting?

=== Do
. In the `gather-images` stage, Jenkins calls the GitLab API to fetch the release tag (e.g. `v1.2.3`).
. Based on this tag, it constructs the container image URL that was built and signed in the staging phase.
. It creates an `images.json` file to describe the image metadata and where it came from.

.Example `images.json`
[source,json,subs="attributes"]
----
{
  "components": [
    {
      "containerImage": "quay.tssc-quay/tssc/my-quarkus-jnk:v1.2.3",
      "source": {
        "git": {
          "url": "{gitlab_url}/development/my-quarkus-jnk",
          "revision": "v1.2.3"
        }
      }
    }
  ]
}
----

=== Explain
This file becomes the source of truth for the validation step. It captures both the image and its corresponding source code revision.

=== Task 2: verify-enterprise-contract

=== Say
* Now comes the security gate. We validate that the image is signed, scanned, and compliant before it goes anywhere near production.

=== Do
. Jenkins runs the `verify-ec` stage using the Red Hat Trusted Application Pipeline shared library.
. It initializes Cosign trust using a TUF server to ensure validation only accepts trusted roots:

[source,bash]
----
cosign initialize \
  --mirror https://tuf.tssc-tas.dev \
  --root https://tuf.tssc-tas.dev/root.json
----

. It validates the image using Enterprise Contract:

[source,bash]
----
ec validate image \
  --image quay.tssc-quay/tssc/my-quarkus-jnk:v1.2.3 \
  --policy default \
  --public-key k8s://openshift/trusted-keys \
  --output json
----

.Sample output
[source,json]
----
{
  "successes": [
    "Image is signed and verified with cosign",
    "SBOM (CycloneDX) is present",
    "Provenance matches repository",
    "No critical vulnerabilities found"
  ],
  "failures": []
}
----

=== Explain
This check bundles multiple security policies into one step:

- Verifies signatures (Cosign)
- Checks for Software Bill of Materials (SBOM)
- Confirms supply chain integrity (SLSA provenance)
- Runs CVE checks
- Enforces any custom org rules

If any of these fail, the pipeline stops immediately — the image is not promoted.

=== Task 3: update-image-tag-for-prod

=== Say
* Now that the image has passed all security gates, we give it a special tag to mark it as production-ready.

=== Do
. In the `update-image-tag-for-prod` stage, Jenkins uses `skopeo` to copy the image and apply a new tag.
. This tag includes a `prod-` prefix to clearly distinguish it from staging or dev versions.

[source,bash]
----
skopeo copy \
  docker://quay.tssc-quay/tssc/my-quarkus-jnk:v1.2.3 \
  docker://quay.tssc-quay/tssc/my-quarkus-jnk:prod-v1.2.3
----

=== Explain
This step doesn’t rebuild the image. It simply re-tags a verified, immutable image — ensuring traceability.

By tagging it `prod-v1.2.3`, we make it clear to downstream systems, release teams, and auditors that:
- The image has passed all validations
- It’s safe and approved for production
- Its origin and promotion path are transparent

=== Task 4: deploy-to-prod

=== Say
* With the production image ready, the last step is to update the deployment configuration so Argo CD can roll it out.

=== Do
. In the `deploy-to-prod` stage, the pipeline uses `rhtap.update_deployment()` to patch the `kustomization.yaml` overlay for production.
. This updates the image tag in the `deployment-patch.yaml` to reference the new production-approved image.

.`deployment-patch.yaml`
[source,yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-quarkus-jnk
spec:
  template:
    spec:
      containers:
        - name: my-quarkus-jnk
          image: quay.tssc-quay/tssc/my-quarkus-jnk:prod-v1.2.3
----

.Sample Git diff
[source,diff]
----
-          image: quay.io/redhat-appstudio/rhtap-task-runner:latest
+          image: quay.tssc-quay/tssc/my-quarkus-jnk:prod-v1.2.3
----

=== Explain
This change is committed and pushed to the GitOps repository under the `overlays/prod/` directory.

Argo CD is continuously watching this repository. Once it sees the update:
- It syncs the manifests
- Deploys the new image to the production cluster
- No manual approval or CLI interaction is needed

This final step completes the promotion workflow — fully automated, fully auditable, and GitOps-native.

== Summary

=== Say
* Let’s wrap up this workflow with a quick summary of what just happened during the production promotion.

=== Do
* Review the following steps to reinforce the end-to-end flow.

[cols="1,1",options="header"]
|===
| Step | Description

| GitLab Release
| Creating a release in GitLab triggers the Jenkins pipeline for production promotion.

| gather-images-to-verify
| Jenkins pulls the image from staging using the Git tag and builds an `images.json`.

| verify-enterprise-contract
| The pipeline validates the image using EC policies — checking signatures, SBOM, provenance, and CVEs.

| Tagging
| Once validated, the image is re-tagged with a `prod-<tag>` suffix to indicate it’s production-ready.

| GitOps Update
| The pipeline updates the `overlays/prod/` directory in the GitOps repo. Argo CD picks up the change and deploys it automatically.
|===

=== Explain
This summary illustrates how production promotion is secure, automated, and fully traceable — using GitOps best practices and Red Hat’s trusted CI/CD tooling.
