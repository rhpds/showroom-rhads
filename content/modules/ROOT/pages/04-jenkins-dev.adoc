== Part 1 — Introduce the Context

=== Say

Let’s take a step back and look at what this demo is really about. Imagine you’re a developer at ACME Corp. You just want to write code and ship features. But what usually slows you down? Setting up CI/CD, figuring out how to wire up webhooks, managing GitOps deployment, and making sure all of it meets your company’s security and compliance standards.

=== Do

Introduce the characters and setup:

* Show the ACME context and explain the developer’s challenge.
* Display the following image to illustrate the Jenkins-based flow:
+
image::jenkins_car.jpg[align="center",width=500]

* Mention ACME Corp as the fictional company used throughout this guide.
* Say: "ACME's platform engineering team has built a system using Red Hat Developer Hub and Advanced Developer Suite to solve this."

=== Explain

Here’s the big picture:

* *Developers* want to move fast and focus on writing code.
* But *DevOps bottlenecks* like setting up CI/CD, webhooks, and policy enforcement slow them down.
* *ACME's platform team* uses *Red Hat Developer Hub* to offer *self-service software templates* that generate a new Quarkus application with *Jenkins pipelines already integrated*.
* The application’s source code is stored in *GitLab*, images go to *Quay*, and Jenkins drives the CI/CD process.

This setup allows teams to:

* Use automation and governance by default
* Avoid manual pipeline setup or policy wiring
* Enable a *Jenkins-based flow* for customers who still rely on it due to existing investments

[NOTE]
====
This demo complements a previous one which used OpenShift Pipelines (Tekton). While Tekton is cloud-native and fully integrated with OpenShift, this version focuses on Jenkins — which remains widely adopted across many enterprise customers.
====

By presenting this Jenkins path, you're addressing a realistic need: helping customers *modernize workflows* without abandoning trusted tooling.



== Part 2 — Scaffold a New Application in Red Hat Developer Hub

. Navigate to {rhdh_url}[Red Hat Developer Hub^] and click *Sign In* on the OIDC prompt.
. Enter your *Username or email*: `{rhdh_user}` and *Password*: `{rhdh_user_password}`.
. In the top-right corner, click the *+* button to start creating a new software component.
. Choose the template: _Securing a Quarkus Service Software Supply Chain (Jenkins)_.

. Accept the default values unless customization is needed. The template collects basic metadata like app name, registry info, and repository setup.

Fields like the following are preconfigured:

.Application Info
|===
| Field | Example Value

| Name | `my-quarkus-jnk`
| Group Id | `redhat.rhdh`
| Artifact Id | `my-quarkus-jnk`
| Java Package Name | `org.redhat.rhdh`
| Description | `A cool Quarkus app`
|===

.Image Registry Info
|===
| Field | Example Value

| Image Registry | `Quay`
| Organization | `tssc`
|===

.Repository Info
|===
| Field | Example Value

| Source Repo | `GitLab`
| Repo Owner | `development`
| Verify Commits | `enabled`
|===

. Click *Review* to verify your inputs, then click *Create* to generate the new application.

[TIP]
====
As the presenter, explain that this step does more than just generate code — it also sets up:

- A fully initialized GitLab repository with source and GitOps manifests
- A signed commit flow if "Verify Commits" is enabled
- CI/CD pipeline integration using Jenkins
- Component registration inside Developer Hub for visibility
====

[NOTE]
====
The `Verify Commits` option enables signing and verification of Git commits using `gitsign`, which integrates with Red Hat’s Trusted Software Supply Chain.
====
---

== Part 3 — What Happens Behind the Scenes

Behind the scenes, Red Hat Developer Hub and the ADS template do the heavy lifting:

* Creates both the **source code** and **GitOps** repositories using information from the template.
* Configures **GitLab webhooks** to trigger Jenkins pipelines on push events.
* Commits **pipeline configuration**, including Jenkinsfiles and Kubernetes manifests.
* Registers the component in the **Developer Hub catalog**, enabling traceability and lifecycle management.
* Automatically triggers the initial CI/CD build if *Verify Commits* is disabled (for demo convenience).

[TIP]
====
Let your audience know:

_"The developer doesn’t have to manually wire any of this. Developer Hub handles everything — Git setup, CI/CD triggers, pipeline configs, and deployment — all in a few clicks."_
====

[NOTE]
====
For customers already using Jenkins, this template shows how ADS can plug into their existing tools while still enforcing secure supply chain policies.
====


== Part 4 — Make a Code Change in DevSpaces

Once the application has been created and registered in the Developer Hub:

. Navigate to the *Catalog* and find your new component (`my-quarkus-jnk`).
. Click on the component name to open the *Overview* page.
. Locate the *OpenShift Dev Spaces* link and click on it — this launches a Red Hat OpenShift Dev Spaces environment preloaded with your project.
. If redirected to the *Red Hat OpenShift* login page, click *Log In with OpenShift* and use the credentials:  
  Username: `{rhdh_user}`  
  Password: `{rhdh_user_password}`
. If prompted, click *Allow selected permissions* on the *Authorize Access* page.
. Click *Continue* on the *Do you trust the authors of this repository?* popup.
. On the *GitLab* authentication page, enter:  
  Username: `{gitlab_user}`  
  Password: `{gitlab_user_password}`  
  and click *Sign in*.
. Click *Authorize devspaces* on the next window.
. Wait for the workspace to fully start.
. If prompted, trust all workspaces and authors.

=== Make a Code Change

. In the DevSpaces IDE, open the file:  
  `my-quarkus-jnk/docs/index.md`
. Add a small change to the file — for example, append a new line of text.

=== Open the Terminal

Open the integrated terminal:

From the top menu bar, click on *Terminal → New Terminal*

This will open a terminal panel at the bottom of the IDE, with your project directory pre-selected.

=== Commit and Push the Change

. Stage your changes:

[source,shell]
----
git add .
----

. Commit your changes:

[source,shell]
----
git commit -m "Update"
----

During this step, `gitsign` will intercept the commit and initiate the signing process. The terminal will display a URL and prompt you to open it in your browser.

. Click the URL to open a browser window and authorize the signing request.
. A verification code will appear in the browser.
. Copy the verification code and return to the terminal.
. Paste the code into the terminal to complete the commit signing process.  
  If prompted, ensure you allow paste functionality.

. Finally, push your changes to GitLab:

[source,shell]
----
git push
----

This push will trigger the CI/CD pipeline via the GitLab webhook.

[NOTE]
====
If *Verify Commits* was enabled when creating the template, a signed commit is required to trigger the pipeline.
====


== Part 5 — Show the Build Pipeline (Jenkins)

In *Developer Hub*, navigate to the *CI* tab of the `my-quarkus-jnk` component.  
You should see three pipeline runs:

- `maven-ci-build`
- `promote-to-stage`
- `promote-to-prod`

The pipeline `maven-ci-build` should be running. Click on *View build* to open Jenkins.

Then click *Open Blue Ocean* to walk through the Jenkins pipeline visually.

== Part 6 - Pipeline Tasks (Jenkins)

As the Jenkins pipeline runs, guide your audience through each of the following stages.  
Each stage demonstrates a step in the secure software supply chain process.

=== Stage: `verify-commit` (conditional)

Say:
This step verifies that the Git commit was signed and trusted.

Do:
Click the `verify-commit` stage in Jenkins.

Explain:
- Uses `gitsign` to validate the commit signature against Red Hat Trusted Application Signer (RHTAS).
- Ensures that only commits from trusted developers are used.
- This stage only appears if the *Verify Commits* option was enabled in the template.

=== Stage: `mvn package`

Say:
Now we package the application using Maven.

Do:
Click the `mvn package` stage.

Explain:
- Compiles the Quarkus Java application.
- Produces a runnable JAR, which becomes the input for the container image.

=== Stage: `init`

Say:
Next, we initialize the environment for the build.

Do:
Click the `init` stage.

Explain:
- Sets up environment variables such as timestamps and image tags.
- Uses the shared `rhtap` Jenkins library to standardize configuration across pipelines.

=== Stage: `build`

Say:
Now we build and sign the container image.

Do:
Click the `build` stage.

Explain:
- Uses `buildah` to create the container image.
- Uses `cosign` to sign the image and generate attestations.
- Guarantees that the image’s source and integrity can be verified later.

=== Stage: `deploy-and-upload-to-tpa` (parallel)

Say:
This stage updates the GitOps repo and uploads the SBOM.

Do:
Expand the `deploy-and-upload-to-tpa` stage.

Explain:
- **deploy**: Updates the GitOps repo with the new image tag, which Argo CD uses to trigger a deployment to the `dev` environment.
- **upload_sbom_to_trustification**: Uploads the Software Bill of Materials (SBOM) to Red Hat Trusted Profile Analyzer (TPA) for scanning and recordkeeping.

To explore the SBOM:
- Visit `{tpa_url}`
- Login using `{tpa_user}` / `{tpa_user_password}`
- Navigate to *SBOMs* in the sidebar

=== Stage: `acs` (parallel)

Say:
Now we run security and compliance checks.

Do:
Expand the `acs` stage.

Explain:
- **acs_deploy_check**: Validates Kubernetes deployment configurations against organizational policy.
- **acs_image_check**: Applies security policies to the built container image.
- **acs_image_scan**: Performs vulnerability scanning using Red Hat Advanced Cluster Security (RHACS).

To review results:
- Visit `{acs_url}`
- Login using `{acs_admin_user}` / `{acs_admin_password}`

=== Stage: `summary`

Say:
The final stage generates a build summary and links all artifacts.

Do:
Click the `summary` stage.

Explain:
- Displays a consolidated view of results, including the SBOM and build status.
- Uses shared functions from the `rhtap` Jenkins library.
- Provides an auditable trail of what was built, scanned, and signed.

=== Pipelines as Code

Say:
Let’s take a quick look at how we define our Jenkins pipeline as code.

Do:
Open the `Jenkinsfile` from the root of the `my-quarkus-jnk` GitLab repository.

Explain:
- The pipeline is defined as code (`Jenkinsfile`) in the same repo as the application.
- This keeps pipeline logic versioned and traceable with the application code.

Benefits for developers:
- No central ticket needed — they can edit their own pipeline.
- Updates follow the same pull request process as app code.
- Fully transparent and self-service.

Benefits for platform/security teams:
- Share reusable logic via the `rhtap` library.
- Apply consistent policy enforcement across all services.
- All pipeline logic is auditable and version-controlled.

In short: *Pipelines as Code* brings automation, compliance, and developer velocity together.


== Part 7 — Summary

Summarize what happened during the demo:

* The developer scaffolded a new Quarkus service using Red Hat Developer Hub
* A secure CI/CD pipeline using Jenkins was automatically configured and triggered
* Commits were signed using gitsign and verified via RHTAS
* Container images were built, signed, scanned, and attested with Cosign, TPA, and ACS
* The service was deployed to development via GitOps — with no manual intervention

== Part 8 — Wrap-Up

Summarize again to reinforce the end-to-end flow:

* Developer created a service in minutes using Developer Hub
* CI/CD pipelines came pre-wired with Jenkins and advanced security integrations
* Commits and container images were cryptographically signed, vulnerability scanned, and policy validated
* GitOps deployment was triggered automatically, completing the promotion

=== Key Takeaways

* *Secure-by-default delivery* — Every change is signed, validated, and scanned automatically
* *Streamlined developer onboarding* — Developers can go from idea to deployment in minutes
* *Governance through automation* — Policy enforcement is built into the process — not bolted on
* *Platform team enablement* — Templates and shared pipelines make it easy to scale best practices
* *Transparency and traceability* — Every step in the lifecycle is logged, auditable, and versioned
* *End-to-end toolchain integration* — GitLab, Quay, Jenkins, and ACS work together out of the box

=== Optional Enhancements

* *Explore the Developer Hub Catalog entry* for the new software component  
  → Highlight metadata such as links to GitLab, pipeline run history, Quay image repository, and RHACS (Advanced Cluster Security) scan results.

* *Show integration depth*  
  → Follow the commit link from Developer Hub to the corresponding GitLab commit.  
  → Open the Jenkins job from the Developer Hub CI tab and view build logs, Blue Ocean pipeline stages, and generated artifacts.

* *Demonstrate template flexibility*  
  → Point out that teams can easily adapt the existing software template to other tech stacks such as Python, Node.js, or Spring Boot.  
  → This approach enables consistent security and deployment practices across diverse applications.

* *Mention collaboration opportunities*  
  → Platform engineers, AppDev leads, and InfoSec teams can co-author templates, enforce common policies, and accelerate delivery while maintaining governance.
