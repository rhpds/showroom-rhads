= Red Hat Developer Hub + Red Hat Advanced Developer Suite Demo Guide
:author: Sales Engineer / Developer Advocate
:revdate: 2025-07-02
:icons!:
:toc:
:toclevels: 1

== Part 1 — Introduce the Context

Know:: Let's take a step back and look at what this demo is really about. Imagine you're a developer at ACME Corp. You just want to write code and ship features. But what usually slows you down? Setting up CI/CD, figuring out how to wire up webhooks, managing GitOps deployment, and making sure all of it meets your company's security and compliance standards.

Here's the big picture:

* *Developers* want to move fast and focus on writing code.
* But *DevOps bottlenecks* like setting up CI/CD, webhooks, and policy enforcement slow them down.
* *ACME's platform team* uses *Red Hat Developer Hub* to offer *self-service software templates* that generate a new Quarkus application with *Jenkins pipelines already integrated*.
* The application's source code is stored in *GitLab*, images go to *Quay*, and Jenkins drives the CI/CD process.

This setup allows teams to:

* Use automation and governance by default
* Avoid manual pipeline setup or policy wiring
* Enable a *Jenkins-based flow* for customers who still rely on it due to existing investments

[NOTE]
====
This demo complements a previous one which used OpenShift Pipelines (Tekton). While Tekton is cloud-native and fully integrated with OpenShift, this version focuses on Jenkins — which remains widely adopted across many enterprise customers.
====

By presenting this Jenkins path, you're addressing a realistic need: helping customers *modernize workflows* without abandoning trusted tooling.

Show::

Introduce the characters and setup:

* Show the ACME context and explain the developer's challenge.
* Display the following image to illustrate the Jenkins-based flow:
+
image::jenkins_car.jpg[align="center",width=500]

* Mention ACME Corp as the fictional company used throughout this guide.
* Say: "ACME's platform engineering team has built a system using Red Hat Developer Hub and Advanced Developer Suite to solve this."

== Part 2 — Scaffold a New Application in Red Hat Developer Hub

Know:: This step does more than just generate code — it also sets up:

- A fully initialized GitLab repository with source and GitOps manifests
- A signed commit flow if "Verify Commits" is enabled
- CI/CD pipeline integration using Jenkins
- Component registration inside Developer Hub for visibility

Behind the scenes, Red Hat Developer Hub and the ADS template do the heavy lifting:

* Creates both the **source code** and **GitOps** repositories using information from the template.
* Configures **GitLab webhooks** to trigger Jenkins pipelines on push events.
* Commits **pipeline configuration**, including Jenkinsfiles and Kubernetes manifests.
* Registers the component in the **Developer Hub catalog**, enabling traceability and lifecycle management.
* Automatically triggers the initial CI/CD build if *Verify Commits* is disabled (for demo convenience).

[TIP]
====
Let your audience know:

_"The developer doesn't have to manually wire any of this. Developer Hub handles everything — Git setup, CI/CD triggers, pipeline configs, and deployment — all in a few clicks."_
====

[NOTE]
====
The `Verify Commits` option enables signing and verification of Git commits using `gitsign`, which integrates with Red Hat's Trusted Software Supply Chain.

For customers already using Jenkins, this template shows how ADS can plug into their existing tools while still enforcing secure supply chain policies.
====

Show::
. Navigate to `{rhdh_url}[Red Hat Developer Hub^]` and click *Sign In* on the OIDC login prompt.
+
image::jenkins-dev-1.png[]
. Enter your credentials:
  - Username: `{rhdh_user}`
  - Password: `{rhdh_user_password}`
. In the top-right corner, click the **+ Self-service** button to create a new software component.
+
image::jenkins-dev-2.png[]
. In the top-right corner, click the *+* button to start creating a new software component.
. Choose the template: _Securing a Quarkus Service Software Supply Chain (Jenkins)_.
+
image::jenkins-dev-3.png[]
. Accept the default values unless customization is needed. The template collects basic metadata like app name, registry info, and repository setup.

Fields like the following are preconfigured:

.Application Info
|===
| Field | Example Value

| Name | `my-quarkus-jnk`
| Group Id | `redhat.rhdh`
| Artifact Id | `my-quarkus-jnk`
| Java Package Name | `org.redhat.rhdh`
| Description | `A cool Quarkus app`
|===

.Image Registry Info
|===
| Field | Example Value

| Image Registry | `Quay`
| Organization | `tssc`
|===

.Repository Info
|===
| Field | Example Value

| Source Repo | `GitLab`
| Repo Owner | `development`
| Verify Commits | `enabled`
|===

. Click *Review* to verify your inputs, then click *Create* to generate the new application.
+
image::jenkins-dev-5.png[]

[TIP]
====
As the presenter, explain that this step does more than just generate code — it also sets up:

- A fully initialized GitLab repository with source and GitOps manifests
- A signed commit flow if "Verify Commits" is enabled
- CI/CD pipeline integration using Jenkins
- Component registration inside Developer Hub for visibility
====

[NOTE]
====
The `Verify Commits` option enables signing and verification of Git commits using `gitsign`, which integrates with Red Hat’s Trusted Software Supply Chain.
====
---

Behind the scenes, Red Hat Developer Hub and the ADS template do the heavy lifting:

* Creates both the **source code** and **GitOps** repositories using information from the template.
* Configures **GitLab webhooks** to trigger Jenkins pipelines on push events.
* Commits **pipeline configuration**, including Jenkinsfiles and Kubernetes manifests.
* Registers the component in the **Developer Hub catalog**, enabling traceability and lifecycle management.
* Automatically triggers the initial CI/CD build if *Verify Commits* is disabled (for demo convenience).

[TIP]
====
Let your audience know:

_"The developer doesn’t have to manually wire any of this. Developer Hub handles everything — Git setup, CI/CD triggers, pipeline configs, and deployment — all in a few clicks."_
====

[NOTE]
====
For customers already using Jenkins, this template shows how ADS can plug into their existing tools while still enforcing secure supply chain policies.
====

== Part 3 — Make a Code Change in OpenShift Dev Spaces

Know:: Once the application has been created and registered in the Developer Hub, we'll demonstrate making a code change using OpenShift Dev Spaces — a cloud IDE experience based on VS Code.

This push will trigger the CI/CD pipeline via the GitLab webhook. Because *Verify Commits* was enabled when the project was created, this change must be signed using `gitsign`.

`gitsign` is a tool that signs Git commits using a short-lived key tied to identity (usually via OpenID Connect). It ensures the commit came from a trusted user — not just anyone with push access.

The following can be verified by signed commits:

* Who made the change
* That the change hasn't been tampered with

The security and auditability of the software supply chain is strengthened by this — a key capability of Red Hat Trusted Application Pipeline.

[NOTE]
====
If *Verify Commits* was enabled when creating the template, a signed commit is required to trigger the pipeline.
====

Show::
. Navigate to the *Catalog* and find your new component (`my-quarkus-jnk`).
+
image::jenkins-dev-6.png[]
. Click on the component name to open the *Overview* page.
. Locate the *OpenShift Dev Spaces* link and click on it — this launches a Red Hat OpenShift Dev Spaces environment preloaded with your project.
+
image::jenkins-dev-7.png[]
. If redirected, click *Log in with OpenShift*
+
image::jenkins-dev-8.png[]
. Sign in with:
  Username: `{rhdh_user}`
  Password: `{rhdh_user_password}`
. If prompted, click *Allow selected permissions* on the *Authorize Access* page.
+
image::jenkins-dev-9.png[]
. On the repository trust prompt, click the checkbox and then click *Continue*
+
image::jenkins-dev-10.png[]
. When prompted to authenticate with GitLab:
+
image::jenkins-dev-11.png[]
  Username: `{gitlab_user}`
  Password: `{gitlab_user_password}`
  and click *Sign in*.
. Click *Authorize devspaces* on the next window.
+
image::jenkins-dev-12.png[]
. Wait for the workspace to fully start.
. Wait for the workspace to start and fully load VS Code
. If prompted, trust all workspaces and authors
+
image::jenkins-dev-13.png[]

In the Dev Spaces IDE:

. Open the file: `my-quarkus-jnk/docs/index.md`
. Add a new line of text at the bottom (e.g., “This is a test edit.”)
. Open the integrated terminal:
  * From the top menu bar, click on `Terminal → New Terminal`
  * This will open a terminal panel at the bottom of the IDE, with your project directory pre-selected
+
image::jenkins-dev-14.png[]

Then, in the terminal:

. Stage your changes:

[source,bash]
----
git add .
----

. Commit your changes:

[source,bash]
----
git commit -m "Update"
----

. The terminal will prompt you with a URL for commit signing via `gitsign`
+
image::jenkins-dev-15.png[]
. Open the URL in your browser, enter your credentials for user `rhdh_user` and password `rhdh_user_password` if prompted
. Copy the verification code shown in the browser
+
image::jenkins-dev-16.png[]
. Paste the code into the terminal to complete the signing process
  (Allow paste functionality if prompted)
+
image::jenkins-dev-17.png[]
. Push your changes:

[source,bash]
----
git push
----

This push will trigger the CI/CD pipeline via the GitLab webhook.

[NOTE]
====
If *Verify Commits* was enabled when creating the template, a signed commit is required to trigger the pipeline.
====


== Part 5 — Show the Build Pipeline (Jenkins)

Know:: What the CI/CD pipeline is doing behind the scenes can be observed now that code has been pushed.

You should see three pipeline runs in Developer Hub: `maven-ci-build`, `promote-to-stage`, and `promote-to-prod`. The pipeline `maven-ci-build` should be running and can be opened in Jenkins using Blue Ocean for visual walkthrough.

Show::
. In *Developer Hub*, navigate to the *CI* tab of the `my-quarkus-jnk` component.
. You should see three pipeline runs:

- `maven-ci-build`
- `promote-to-stage`
- `promote-to-prod`

image::jenkins-dev-18.png[]

. Click on *View build* to open Jenkins.
. Click *Open Blue Ocean* to walk through the Jenkins pipeline visually.

image::jenkins-dev-19.png[]

== Part 6 — Jenkins Pipeline Tasks

image::jenkins-dev-20.png[]

Know:: As the Jenkins pipeline runs, guide your audience through each stage. Each step supports secure software supply chain automation.

=== Stage: verify-commit (optional)
This verifies that the Git commit was signed and trusted.

* Uses `gitsign` and Red Hat Trusted Application Signer (RHTAS) to verify commit authenticity.
* Ensures the commit came from a known developer.
* This stage appears only if *Verify Commits* was enabled in the software template.

=== Stage: mvn package
Now we compile and package the Quarkus application.

* Runs `mvn package` to build the Java app.
* Produces the runnable JAR used for container image creation.

=== Stage: init
Next, we prepare the environment for the build.

* Sets environment variables (e.g., Git tag, timestamp, registry).
* Uses the shared `rhtap` Jenkins library to standardize CI behavior.

=== Stage: build
Let's build and sign the container image.

* Uses `buildah` to containerize the app.
* Uses `cosign` to sign the image and generate provenance metadata.

=== Stage: deploy-and-upload-to-tpa (parallel)
This stage handles GitOps deployment and SBOM upload.

* *deploy*: updates the GitOps repo with the new image tag — this triggers Argo CD to redeploy the app to dev.
* *upload_sbom_to_trustification*: pushes the SBOM to Red Hat Trusted Profile Analyzer (TPA) for compliance tracking.

Visit `{tpa_url}[Red Hat Trusted Profile Analyzer^]` and log in with `{tpa_user}` / `{tpa_user_password}` to explore SBOM results.

=== Stage: acs (parallel)
Now we perform security and policy checks.

* *acs_deploy_check*: verifies Kubernetes manifests (e.g., RBAC, host access).
* *acs_image_check*: enforces policy on image config.
* *acs_image_scan*: performs vulnerability scanning using Red Hat Advanced Cluster Security (RHACS).

Visit `{acs_url}[Red Hat Advanced Cluster Security^]` using `{acs_admin_user}` / `{acs_admin_password}` to see the results.

=== Stage: summary
This final stage summarizes the build and validations.

* Shows build status and key artifacts (e.g., SBOM, scan summary).
* Uses reusable functions from the `rhtap` library.

=== Pipelines as Code
Let's quickly look at the pipeline definition inside the codebase.

* This is a *Pipelines as Code* setup — the CI logic lives alongside app code.
* Easy to update via PRs. Version-controlled. No central team required.

*Benefits for developers:*
* Fast iteration, no ticketing for pipeline changes.
* Clear visibility and ownership over CI/CD.

*Benefits for ACME (platform/security teams):*
* Shared libraries enforce security policies and reusability.
* Full audit trail across all stages of the pipeline.

Show::
. Click the `verify-commit` stage in the Jenkins UI.
. Click the `mvn package` stage.
. Click the `init` stage.
. Click the `build` stage.
. Expand the `deploy-and-upload-to-tpa` stage.
. Expand the `acs` stage.
. Click the `summary` stage.
. Open the `Jenkinsfile` in the root of the `my-quarkus-jnk` GitLab repo.


== Part 7 — Summary

Summarize what happened during the demo:

* The developer scaffolded a new Quarkus service using Red Hat Developer Hub
* A secure CI/CD pipeline using Jenkins was automatically configured and triggered
* Commits were signed using gitsign and verified via RHTAS
* Container images were built, signed, scanned, and attested with Cosign, TPA, and ACS
* The service was deployed to development via GitOps — with no manual intervention

== Part 8 — Wrap-Up

Summarize again to reinforce the end-to-end flow:

* Developer created a service in minutes using Developer Hub
* CI/CD pipelines came pre-wired with Jenkins and advanced security integrations
* Commits and container images were cryptographically signed, vulnerability scanned, and policy validated
* GitOps deployment was triggered automatically, completing the promotion

=== Key Takeaways

* *Secure-by-default delivery* — Every change is signed, validated, and scanned automatically
* *Streamlined developer onboarding* — Developers can go from idea to deployment in minutes
* *Governance through automation* — Policy enforcement is built into the process — not bolted on
* *Platform team enablement* — Templates and shared pipelines make it easy to scale best practices
* *Transparency and traceability* — Every step in the lifecycle is logged, auditable, and versioned
* *End-to-end toolchain integration* — GitLab, Quay, Jenkins, and ACS work together out of the box

=== Optional Enhancements

* *Explore the Developer Hub Catalog entry* for the new software component
  → Highlight metadata such as links to GitLab, pipeline run history, Quay image repository, and RHACS (Advanced Cluster Security) scan results.

* *Show integration depth*
  → Follow the commit link from Developer Hub to the corresponding GitLab commit.
  → Open the Jenkins job from the Developer Hub CI tab and view build logs, Blue Ocean pipeline stages, and generated artifacts.

* *Demonstrate template flexibility*
  → Point out that teams can easily adapt the existing software template to other tech stacks such as Python, Node.js, or Spring Boot.
  → This approach enables consistent security and deployment practices across diverse applications.

* *Mention collaboration opportunities*
  → Platform engineers, AppDev leads, and InfoSec teams can co-author templates, enforce common policies, and accelerate delivery while maintaining governance.
