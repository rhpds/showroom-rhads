= Red Hat Developer Hub + Red Hat Advanced Developer Suite Demo Guide
:author: Sales Engineer / Developer Advocate
:revdate: 2025-07-02
:icons!:
:toc:
:toclevels: 1

== Part 1 — Set the Stage

Say::
Before we jump into building anything, let’s take a step back and understand the context for this demo.

Do::
You're a platform engineer at *Acme Retail*. Your development teams are building a new Quarkus-based checkout microservice. They want to move fast — but the current process introduces friction:

* Developers rely on the platform team to set up Git repos, CI/CD pipelines, and Kubernetes manifests.
* Security practices like commit signing, SBOM generation, and image scanning are often manual or skipped.
* Pipeline setups vary across teams, which leads to governance gaps and duplicated effort.

Explain::
This demo shows how *Red Hat Developer Hub (RHDH)* and *Red Hat Advanced Developer Suite (RHADS)* help solve these problems through a secure, self-service developer experience.

We’ll walk through how a developer at Acme can:

* Scaffold a new service from a secure template
* Automatically create GitLab repos and OpenShift Pipelines
* Push images to Quay with SBOMs, signing, and attestations
* Enforce policy gates through tools like Trusted Application Pipeline and ACS

The goal is to help Acme deliver software faster, with governance and security built in.

image::tekton_car.jpg[align="center",width=500]

== Part 2 — Scaffold a New Application in Red Hat Developer Hub

Say::
Now that we understand the problem, let’s show how a developer at Acme Retail would use Red Hat Developer Hub to scaffold a secure, production-ready application — without any manual setup.

Do::
. Navigate to `{rhdh_url}` and click *Sign In* on the OIDC login prompt.
+
image::tekton-dev-1.png[]
. Enter your credentials:
  - Username: `{rhdh_user}`
  - Password: `{rhdh_user_password}`
. In the top-right corner, click the **+ Self-service** button to create a new software component.
+
image::tekton-dev-2.png[]
. Select the template:
  _Securing a Quarkus Service Software Supply Chain (Tekton)_
+
image::tekton-dev-3.png[]
. Accept the default values provided in the form unless customization is needed.

Application Information:
[cols="1,2", options="header"]
|===
| Field | Default Value
| Name | `my-quarkus-tkn`
| Group ID | `redhat.rhdh`
| Artifact ID | `my-quarkus-tkn`
| Java Package Name | `org.redhat.rhdh`
| Description | `A cool Quarkus app`
|===

. Click *Next*

Image Registry Information:
[cols="1,2", options="header"]
|===
| Field | Default Value
| Image Registry | `Quay`
| Organization | `tssc`
|===

. Click *Next*

Repository Information:
[cols="1,2", options="header"]
|===
| Field | Default Value
| Source Repo | `GitLab`
| Repo Owner | `development`
| Verify Commits | `enabled`
|===

. Click *Review*, then click *Create*
+
image::tekton-dev-4.png[]

Explain::
This single action bootstraps the entire delivery stack for the developer:

* A new GitLab repo (source + GitOps) is created under the `development` group
* Secure CI/CD pipelines are generated using OpenShift Pipelines
* Image builds are configured to push to the `tssc` organization in Quay
* Commit signing and SBOM generation are included automatically
* The component is registered in the Developer Hub catalog for visibility

The developer doesn't have to write YAML or coordinate with platform or security teams — it’s all baked into the golden path template.

image::tekton-dev-5.png[]

== Part 3 — Make a Code Change in OpenShift Dev Spaces

Say::
Now that the application has been scaffolded and registered, let’s make a code change using OpenShift Dev Spaces — a cloud IDE experience based on VS Code.

Do::
. In Red Hat Developer Hub, go to the *Catalog* and locate your new component (`my-quarkus-tkn`)
+
image::tekton-dev-6.png[]
. Click the component name to open its *Overview* page
. Find and click the *OpenShift Dev Spaces* link to launch a preloaded workspace
+
image::tekton-dev-7.png[]
. If redirected, click *Log in with OpenShift*
+
image::tekton-dev-8.png[]
. Sign in with:
  - Username: `{rhdh_user}`
  - Password: `{rhdh_user_password}`
. On the *Authorize Access* screen, click *Allow selected permissions*
+
image::tekton-dev-9.png[]
. On the repository trust prompt, click the checkbox and then click *Continue*
+
image::tekton-dev-10.png[]
. When prompted to authenticate with GitLab:
+
image::tekton-dev-11.png[]
  - Username: `{gitlab_user}`
  - Password: `{gitlab_user_password}`
. Click *Authorize devspaces*
+
image::tekton-dev-12.png[]
. Wait for the workspace to start and fully load VS Code
. If prompted, trust all workspaces and authors
+
image::tekton-dev-13.png[]

In the Dev Spaces IDE:

. Open the file: `my-quarkus-tkn/docs/index.md`
. Add a new line of text at the bottom (e.g., “This is a test edit.”)
. Open the integrated terminal:
  * From the top menu bar, click on `Terminal → New Terminal`
  * This will open a terminal panel at the bottom of the IDE, with your project directory pre-selected
+
image::tekton-dev-14.png[]

Then, in the terminal:

. Stage your changes:

[source,bash]
----
git add .
----

. Commit your changes:

[source,bash]
----
git commit -m "Update"
----

. The terminal will prompt you with a URL for commit signing via `gitsign`
+
image::tekton-dev-15.png[]
. Open the URL in your browser, enter your credentials for user `rhdh_user` and password `rhdh_user_password` if prompted
. Copy the verification code shown in the browser
+
image::tekton-dev-16.png[]
. Paste the code into the terminal to complete the signing process
  (Allow paste functionality if prompted)
+
image::tekton-dev-17.png[]
. Push your changes:

[source,bash]
----
git push
----

image::tekton-dev-18.png[]

Explain::
This push triggers the CI/CD pipeline via the GitLab webhook.

Because *Verify Commits* was enabled when you created the project, this change must be signed using `gitsign`.

`gitsign` is a tool that signs your Git commits using a short-lived key tied to your identity (usually via OpenID Connect). This ensures the commit came from a trusted user — not just anyone with push access.

Signed commits help verify:
* Who made the change
* That the change hasn’t been tampered with

This strengthens the security and auditability of your software supply chain — a key capability of Red Hat Trusted Application Pipeline.

== Part 4 — What Happens Behind the Scenes

Once the user clicks *Create* in Developer Hub, a lot of powerful automation kicks in — without the developer needing to manually configure anything.

Say this:

> “Let’s pause and see what just happened behind the scenes when the developer created the app using the template.”

Then explain:

Red Hat Developer Hub, working together with the template and platform tools, automates the following steps:

* Creates a **source code repository** (application code) and a **GitOps repository** (deployment manifests) using GitLab
* Sets up **GitLab webhooks** to trigger the correct CI/CD pipeline for this app
* Commits pre-built **pipeline definitions** and Kubernetes manifests into the appropriate repos
* Registers the app as a **catalog component** inside Developer Hub so developers can monitor it
* Automatically **triggers the CI/CD build pipeline** if "Verify Commits" was set to `false` (i.e., unsigned commits allowed)

Say this:

> “That’s a full-stack DevSecOps setup from day one — source, pipelines, GitOps, CI/CD, and visibility — ready to go without any manual effort.”

This approach ensures consistency, reduces setup time, and gives platform teams confidence that every service adheres to policy from the outset.

== Part 5 — Show the Build Pipeline (OpenShift Pipelines)

Say this:

> “Now that we’ve pushed code, let’s switch over to see what the CI/CD pipeline is doing behind the scenes.”

In *Red Hat Developer Hub*, navigate to the `CI` tab and click on the running `maven-build-ci` pipeline.
+
image::tekton-dev-18.png[]

Walk your audience through each stage of the pipeline to show how it enforces security and automation at every step.

=== Task 1: `init`

Initializes pipeline resources and artifacts required for this pipeline run.
This sets up any reusable components needed downstream.

=== Task 2: `clone-repository`

Clones the source code repository that triggered the pipeline.
This ensures the latest code is fetched for verification and build.

=== Task 3: `verify-commit`

Verifies the Git commit signature using the `gitsign` tool, which is integrated with Red Hat Trusted Application Pipeline (RHTAP).
This step ensures the commit comes from a trusted source and hasn’t been tampered with.

> Clicking on this task in the pipeline UI will show details like who signed the commit and whether it passed verification.

=== Task 4: `package`

Builds the Java source code and creates a Maven artifact — in this case, a Quarkus JAR file.

=== Task 5: `build-container`

Builds a container image for the Quarkus application.

It then:
* Signs the image using **Cosign**
* Generates an **SBOM** (Software Bill of Materials)
* Attests the image using **in-toto** for provenance

> The image tag corresponds to the Git commit ID that triggered the pipeline.

=== Task 6.1: `upload-sboms-to-trustification`

Uploads the SBOM to **Red Hat Trusted Profile Analyzer (TPA)** so teams can analyze it for CVEs, vendor advisories, and vulnerabilities.

> You can access TPA at {tpa_url}[Red Hat Trusted Profile Analyzer^] using username `{tpa_user}` and password `{tpa_user_password}`.
> Click *SBOMs* on the left menu to view results.

=== Task 6.2: `update-deployment`

Commits the new image reference into the GitOps repository.
This allows **OpenShift GitOps** (Argo CD) to automatically deploy the new version.

=== Task 7.1: `acs-image-check`

Performs policy checks on the container image using **Red Hat Advanced Cluster Security (ACS)**.

> Ensures the image doesn’t violate any organization-defined security policies.

=== Task 7.2: `acs-image-scan`

Scans the image for known vulnerabilities and generates a report.

> Clicking on this step shows CVEs and risk scores identified in the image.

=== Task 7.3: `acs-deploy-check`

Evaluates the deployment configuration and image from a security and compliance perspective.

> Stores the results in ACS for auditability and enforcement.

> You can also visit ACS at {acs_url} using `{acs_admin_user}` / `{acs_admin_password}` to explore deeper policy and scan results.

=== Task 8.1: `show-sbom`

Displays the SBOM generated in earlier stages.

=== Task 8.2: `show-summary`

Shows a high-level summary of the build, verification, signing, and scan results.

---

Say this:

> “As you can see, these aren’t just traditional CI steps. Every stage adds a layer of trust, traceability, and security — without slowing down the developer.”

Explain:

These steps are not optional or best-effort — they are **enforced** through policy and integrated tooling, giving teams security by default.

=== Brief Note on Pipelines as Code

These pipelines are defined and version-controlled alongside the application code.

This design makes the CI/CD process:

* Transparent — developers can see exactly how their builds work
* Consistent — pipelines follow a shared structure across projects
* Adaptable — changes to pipelines are tracked like any other code

For developers at ACME:

* No need to file tickets or wait on DevOps — pipelines are part of the repo.
* They can propose updates to pipeline steps via pull requests, just like application code.
* It’s easier to understand how a change moves from code to container to deployment.

For the ACME platform team:

* Pipeline templates enforce security, compliance, and best practices automatically.
* Updates to shared logic (like SBOM scanning or image signing) can be reused across all projects.
* With pipelines stored alongside code, it’s easier to troubleshoot and audit each change.

Say this:

> “This approach gives developers more autonomy while ensuring the platform team still enforces security and governance by default.”

Keep it brief — the goal is to reinforce how this approach scales and empowers both sides.

== Part 6 — Summary

* Developer created a service in minutes using Red Hat Developer Hub
* Secure CI/CD pipeline was pre-wired through the selected software template
* Commits and container images were signed, scanned, and attested as part of the automated workflow

== Part 7 — Wrap-Up

This demo showcases how Red Hat Developer Hub and the Advanced Developer Suite enable secure, scalable developer workflows:

=== Key Takeaways

* *Secure-by-default delivery* — Every code change is validated, scanned, and signed automatically
* *Streamlined developer onboarding* — Developers can get started with new services in minutes using self-service templates
* *Governance through automation* — Security and compliance policies are enforced through the pipeline, not manual reviews
* *Platform team enablement* — Templates and pipelines are reusable, scalable, and consistent across teams
* *Transparency and traceability* — Every step from commit to deployment is auditable and visible
* *Toolchain integration* — GitLab, Quay, OpenShift Pipelines, and ACS work together to provide a seamless secure supply chain experience


=== Optional Enhancements

* *Explore the Developer Hub Catalog entry* for the new software component
  - Highlight metadata like links to GitLab, pipeline history, Quay images, and RHACS results.

* *Show integration depth*
  - Follow the commit link from Developer Hub to GitLab.
  - View the running OpenShift Pipelines execution and associated artifacts.

* *Demonstrate template flexibility*
  - Mention how teams can build similar templates for other tech stacks like Python, Node.js, or Spring Boot.

* *Highlight collaboration opportunities*
  - Emphasize how platform and security teams can co-develop templates and pipelines to bake in policy and compliance.
